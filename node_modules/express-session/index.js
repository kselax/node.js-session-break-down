/*!
 * express-session
 * Copyright(c) 2010 Sencha Inc.
 * Copyright(c) 2011 TJ Holowaychuk
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */

// it doesn't allow using some syntax
'use strict';

/**
 * Module dependencies.
 * @private
 */
// Basic HTTP cookie parser and serializer for HTTP servers.
var cookie = require('cookie');
// Module for calculating Cyclic Redundancy Check (CRC) for Node.js and the Browser.
var crc = require('crc').crc32;
// A tiny JavaScript debugging utility modelled after Node.js core's debugging technique. Works in Node.js and web browsers.
var debug = require('debug')('express-session');
// Deprecate all the things
// With great modules comes great responsibility; mark things deprecated!
var deprecate = require('depd')('express-session');
// Parse a URL with memoization.
var parseUrl = require('parseurl');
/*URL and cookie safe UIDs
Create cryptographically secure UIDs safe for both cookie and URL usage. This is in contrast to modules such as rand-token and uid2 whose UIDs are actually skewed due to the use of % and unnecessarily truncate the UID. Use this if you could still use UIDs with - and _ in them. */
var uid = require('uid-safe').sync
// Execute a listener when a response is about to write headers.
// This will add the listener listener to fire when headers are emitted for res. The listener is passed the response object as it's context (this). Headers are considered to be emitted only once, right before they are sent to the client.
  , onHeaders = require('on-headers')
// sign and unsign cookies
  , signature = require('cookie-signature')

// here we get function Session to varialbe Session
// for creating an object we have to use a keyword 'new'
var Session = require('./session/session')
  , MemoryStore = require('./session/memory')
  , Cookie = require('./session/cookie')
  , Store = require('./session/store');

// console.log(Session); // [Function: Session]


// environment

var env = process.env.NODE_ENV;
// console.log(env); undefined

/**
 * Expose the middleware.
 */
// export function that uses for initialization in middleware
exports = module.exports = session;

/**
 * Expose constructors.
 */

exports.Store = Store;
exports.Cookie = Cookie;
// constructor for creating session object
exports.Session = Session;
exports.MemoryStore = MemoryStore;

/**
 * Warning message for `MemoryStore` usage in production.
 * @private
 */

// this is string variable
var warning = 'Warning: connect.session() MemoryStore is not\n'
  + 'designed for a production environment, as it will leak\n'
  + 'memory, and will not scale past a single process.';

/**
 * Node.js 0.8+ async implementation.
 * @private
 */

/* istanbul ignore next */
// typeof operator return string value of a variable type
// it might return 'function' if variable setImmediate is function
// what is going on here?
// creating varialbe defer that is has a function that placed in a variable setImmediate,
// if it doesn't have a function it will create own function
//
// setImmediate - This method is used to break up long running operations and run a callback function immediately after the browser has completed other operations such as events and display updates.
// if (err) {
//   defer(next, err);
// }
// in this code setImmediate puts functin to an event loop
// process.nextTick() practically does the same like setImmediate
// both functions accept other function, in our example we do
// defer(next, err); it will setImmediate(next, err) or process.nextTick(next, err)
// where next is a funciton and err is a variable that will pass to next as a argument.
var defer = typeof setImmediate === 'function'
  ? setImmediate
  : function(fn){ process.nextTick(fn.bind.apply(fn, arguments)) }
// console.log(defer); // { [Function: setImmediate] [Symbol(util.promisify.custom)]: [Function] }
/**
 * Setup session store with the given `options`.
 *
 * @param {Object} [options]
 * @param {Object} [options.cookie] Options for cookie
 * @param {Function} [options.genid]
 * @param {String} [options.name=connect.sid] Session ID cookie name
 * @param {Boolean} [options.proxy]
 * @param {Boolean} [options.resave] Resave unmodified sessions back to the store
 * @param {Boolean} [options.rolling] Enable/disable rolling session expiration
 * @param {Boolean} [options.saveUninitialized] Save uninitialized sessions to the store
 * @param {String|Array} [options.secret] Secret for signing session ID
 * @param {Object} [options.store=MemoryStore] Session store
 * @param {String} [options.unset]
 * @return {Function} middleware
 * @public
 */

// this is a main of this middleware
function session(options) {
  // var equal options or object
  var opts = options || {}
  // console.log(opts);
  // get the cookie options
  var cookieOptions = opts.cookie || {}

  // get the session id generate function
  // here is initialization fo generateId function
  // by defult it's generateSessionId
  // function generateSessionId(sess) {
  //   return uid(24);
  // }
  // this is define in bottom
  var generateId = opts.genid || generateSessionId
  // console.log(generateId);
  // get the session cookie name
  var name = opts.name || opts.key || 'connect.sid'

  // get the session store
  // if not exists store we use MemoryStore
  var store = opts.store || new MemoryStore()
  // console.log(store.serializer.stringify);

  // get the trust proxy setting
  var trustProxy = opts.proxy

  // get the resave session option
  // could be true or false
  var resaveSession = opts.resave;

  // get the rolling session option
  var rollingSessions = Boolean(opts.rolling)

  // get the save uninitialized session option
  // it could be true or false
  var saveUninitializedSession = opts.saveUninitialized

  // get the cookie signing secret
  var secret = opts.secret

  // typeof operator returns string in this case if it doesn't return 'function'
  // will be thrown an exception
  // throw new TypeError('genid option must be a function');
  if (typeof generateId !== 'function') {
    // The TypeError object represents an error when a value is not of the expected type.
    // shortly this thin is spawn an exception
    throw new TypeError('genid option must be a function');
  }

  // if we didn't define resave parameter it will show message
  if (resaveSession === undefined) {
    // it's function from dept module that is mark everything in your module as depricated
    deprecate('undefined resave option; provide resave option');
    resaveSession = true; // this is by default value
  }
  // if you didn't specify explicitely value for saveUninitializedSession
  // you'll get warning message
  if (saveUninitializedSession === undefined) {
    // it's output message for your module, see npm module dept
    deprecate('undefined saveUninitialized option; provide saveUninitialized option');
    saveUninitializedSession = true; // set up default value for
  }

  // console.log(opts.unset); // undefined
  // by default it's undefined
  // here is going on checking, destroy or keep if distinguish than throw an exception
  if (opts.unset && opts.unset !== 'destroy' && opts.unset !== 'keep') {
    // TypeError is object represents an error when a value is not of the expected type
    throw new TypeError('unset option must be "destroy" or "keep"');
  }

  // TODO: switch to "destroy" on next major
  // if opts.unset === destroy our var unsetDestroy will be getting true,
  // by default it gets false
  var unsetDestroy = opts.unset === 'destroy'
  // console.log(unsetDestroy);

  //  what is Array.isArray()
  // Array.isArray - method determines whether the passed value is Array
  // console.log(secret);
  // it's check secret, and if it is empty might throw an exception
  if (Array.isArray(secret) && secret.length === 0) {
    // TypeError - object represents an error when the value is not of the expected type
    throw new TypeError('secret option array must contain one or more strings');
  }

  // if secret == true and secret is not Array
  // it will translate secret to Array
  if (secret && !Array.isArray(secret)) {
    // console.log('here we go');
    // transform secret to Array
    secret = [secret];
    // console.log(secret);
  }

  // check if you didn't specify explicitely secret, you'll get an error
  // from a dept node modules
  if (!secret) {
    // output an error from dept modules by funciton depricated
    deprecate('req.secret; provide secret option');
  }

  // notify user that this store is not
  // meant for a production environment
  /* istanbul ignore next: not tested */
  // output warnings if you use databse by defult MemoryStore that is not used for
  // production, you have to use one other
  if ('production' == env && store instanceof MemoryStore) {
    // outputs the warning message to the web console
    // difference with output in browser console it will have icon
    console.warn(warning);
  }

  // generates the new session
  // what is going on here
  // console.log(store);
  // here we add a new member to object store and asign to it a function
  // other words we add function to our store object
  // store object represents a database, it could be Redis or whatever you wnat
  // here is define a funciton definition
  store.generate = function(req){
    // console.log(req);
    // it has function that use node.js module uid-safe for generating uid
    req.sessionID = generateId(req);
    // this is a session object from file Session = require('./session/session')
    req.session = new Session(req);
    // what is the Cookie object
    // this is object from file Cookie = require('./session/cookie')
    req.session.cookie = new Cookie(cookieOptions);

    // what is going on here?
    if (cookieOptions.secure === 'auto') {
      // issecure - is custom function defined in the bottom
      // trustProxy - is a value from user input opts.proxy
      // definition from npm
      // proxy
      // Trust the reverse proxy when setting secure cookies (via the "X-Forwarded-Proto" header).
      // The default value is undefined.
      // true The "X-Forwarded-Proto" header will be used.
      // false All headers are ignored and the connection is considered secure only if there is a direct TLS/SSL connection.
      // undefined Uses the "trust proxy" setting from express
      // issecure return false or true, here we set up property secure to object Coockie
      req.session.cookie.secure = issecure(req, trustProxy);
    }
    // console.log(this);
  };
  // console.log(store);

  // if typeof return functon than variable true
  var storeImplementsTouch = typeof store.touch === 'function';

  // register event listeners for the store to track readiness
  var storeReady = true
  store.on('disconnect', function ondisconnect() {
    // console.log('here we go disconnect');
    storeReady = false
  })
  store.on('connect', function onconnect() {
    // console.log('here we go connect');
    storeReady = true
  })


  // this is looks like closure
  return function session(req, res, next) {

    // self-awareness
    // if req.session exists go to next middleware
    if (req.session) {
      next()
      return
    }

    // Handle connection as if there is no session if
    // the store has temporarily disconnected etc
    // if database off, go to next middleware by next function and outptu error
    if (!storeReady) {
      // output when DEBUG=express-session node index.js
      debug('store is disconnected')
      next()
      return
    }

    // pathname mismatch
    // [mark]
    // console.log(req);
    // console.log(parseUrl.original(req));
    // console.log(parseUrl(req));
    // console.log(parseUrl.original(req).path);
    // parseUrl it's modul functions parseurl
    var originalPath = parseUrl.original(req).pathname || '/'
    // console.dir(originalPath); // '/'

    // indexOf return position in array;
    // console.log(cookieOptions.path); // undefined
    // if not exists cookieOptions.path than look '/' symbol
    // if !== 0 it means it is not first symbol, go to next middleware
    // console.log(originalPath.indexOf(cookieOptions.path || '/')); // 0
    if (originalPath.indexOf(cookieOptions.path || '/') !== 0) return next();

    // ensure a secret is available or bail
    // console.log(req.secret); // undefined
    // console.log(secret); // [ 'keyboard cat' ]
    // next(new Error('secret option required for sessions')); // it will stop app and output error
    // next('some text'); // it will output some text
    if (!secret && !req.secret) {
      //The Error constructor creates an error object. Instances of Error objects are thrown when runtime errors occur.
      next(new Error('secret option required for sessions'));
      return;
    }

    // backwards compatibility for signed cookies
    // req.secret is passed from the cookie parser middleware
    // if secret false then req.secret
    var secrets = secret || [req.secret];

    var originalHash;
    var originalId;
    var savedHash;
    var touched = false

    // expose store
    req.sessionStore = store;

    // get the session ID from the cookie
    // cookieId should be like this G2l2hgtne35pqLWNVv0G4tWtjCWPm5nf
    var cookieId = req.sessionID = getcookie(req, name, secrets);
    // console.log('cookieId = ' + cookieId); // G2l2hgtne35pqLWNVv0G4tWtjCWPm5nf

    // set-cookie
    // [mark]
    // onHeaders = require('on-headers')
    // this is function npm module on-headers, accept res and cusom function
    onHeaders(res, function(){
      if (!req.session) {
        debug('no session');
        return;
      }

      // this is a custom function
      // shouldSetCookie returns false or true and checks
      //  false when typeof req.sessionID !== string
      if (!shouldSetCookie(req)) {
        return;
      }

      // only send secure cookies via https
      if (req.session.cookie.secure && !issecure(req, trustProxy)) {
        debug('not secured');
        return;
      }

      // if touch not false
      // console.log('touched = ' + touched);
      // console.log('req.session.cookie.maxAge = ' + req.session.cookie.maxAge);
      // if false need to refresh cookie MaxAge
      if (!touched) {
        // touch session
        // console.log('here we go');
        // touch is session function that calls resetMaxAge
        // this.cookie.maxAge = this.cookie.originalMaxAge;
        req.session.touch()
        touched = true // set up flag to true
      }

      // set cookie
      // req.session.cookie.data it has get data() inside cookie object
      // name by default is var name = opts.name || opts.key || 'connect.sid'
      // setcoookie - set cookies to header res.setHeader('set-cookie', header)
      setcookie(res, name, req.sessionID, secrets[0], req.session.cookie.data);
    }); // onHeaders(res, function(){



    // proxy end() to commit the session
    var _end = res.end;
    var _write = res.write;
    var ended = false; // this is flag for calling once end() function
    // this is closure for res.end function
    res.end = function end(chunk, encoding) {
      // call it only once
      if (ended) {
        return false;
      }

      ended = true;

      var ret;
      var sync = true; // this is protection for colling once writeend function

      // return ret
      function writeend() {
        if (sync) {
          // _end has origin res.end
          // here we call origin res.end and pass this ans res, and two arguments chunk, encoding
          ret = _end.call(res, chunk, encoding);
          sync = false; // set to fals for not running second time this code
          return;
        }

        // if it call second time do without parameters
        _end.call(res);
      } // function writeend() {

      // funciton return ret
      function writetop() {
        if (!sync) {
          return ret; // ret = _end.call(res, chunk, encoding);
        }
        // if chat == null then return ret = true
        if (chunk == null) {
          ret = true;
          return ret;
        }
        // console.log(res.getHeader('Content-Length'));
        // Number translates string to Number
        var contentLength = Number(res.getHeader('Content-Length'));
        // if contentLength is not NaN and more zero
        if (!isNaN(contentLength) && contentLength > 0) {

          // measure chunk
          // if chat not buffer create a new buffer
          chunk = !Buffer.isBuffer(chunk)
            // create a new Buffer
            ? new Buffer(chunk, encoding)
            // else chank
            : chunk;
          encoding = undefined;

          if (chunk.length !== 0) {
            debug('split response');
            // _write = res.write
            // res is this, arguments chun
            ret = _write.call(res, chunk.slice(0, chunk.length - 1));
            chunk = chunk.slice(chunk.length - 1, chunk.length);
            return ret;
          }
        } // if (!isNaN(contentLength) && contentLength > 0) {
        // _write = res.write
        ret = _write.call(res, chunk, encoding);
        sync = false;

        return ret;
      } // function writetop() {

      // what is going on here
      // shouldDestroy returns this: return req.sessionID && unsetDestroy && req.session == null;
      if (shouldDestroy(req)) {
        // destroy session
        debug('destroying');
        store.destroy(req.sessionID, function ondestroy(err) {
          if (err) {
            defer(next, err);
          }

          debug('destroyed');
          writeend(); // return ret
        });

        return writetop(); // return ret
      } // if (shouldDestroy(req)) {

      // no session to save
      if (!req.session) {
        debug('no session');
        return _end.call(res, chunk, encoding);
      }

      // exists session for saving

      // resetMaxAge
      if (!touched) {
        // touch session
        req.session.touch()
        touched = true
      }

      // return true if session should be saved and if not false
      if (shouldSave(req)) {
        req.session.save(function onsave(err) {
          if (err) {
            defer(next, err);
          }

          writeend();
        });

        return writetop();
      } else if (storeImplementsTouch && shouldTouch(req)) {
        // store implements touch method
        debug('touching');
        store.touch(req.sessionID, req.session, function ontouch(err) {
          if (err) {
            defer(next, err);
          }

          debug('touched');
          writeend();
        });

        return writetop();
      } // } else if (storeImplementsTouch && shouldTouch(req)) {
      // call _end=res.end with this = res and two arguments chunk and encoding
      return _end.call(res, chunk, encoding);
    }; // res.end = function end(chunk, encoding) /* listener for res.end() */

    // generate the session
    function generate() {
      store.generate(req); // unknown function
      originalId = req.sessionID;
      originalHash = hash(req.session);
      wrapmethods(req.session); // put two method to session
    }

    // wrap session methods
    // this is a closure that add to session session two functions reload and save
    function wrapmethods(sess) {
      var _reload = sess.reload
      var _save = sess.save;

      function reload(callback) {
        debug('reloading %s', this.id)
        // pass this and function that put wrapper to session
        _reload.call(this, function () {
          wrapmethods(req.session)
          callback.apply(this, arguments) // pass this and pass arguments
        })
      }

      function save() {
        debug('saving %s', this.id);
        savedHash = hash(this);
        _save.apply(this, arguments); // pass current this with arguments
      }
      // add property to current object, sess is object
      Object.defineProperty(sess, 'reload', {
        configurable: true,
        enumerable: false,
        value: reload, // reload is function define above
        writable: true
      })
      // add property save to object sess
      Object.defineProperty(sess, 'save', {
        configurable: true,
        enumerable: false,
        value: save, // save is function define above
        writable: true
      });
    } // function wrapmethods(sess) {

    // check if session has been modified
    // this is closure function that return false or true
    // see is req.session object
    // return true if originalId !== sess.id OR
    // originalHash !== hash(sess)
    function isModified(sess) {
      // return true if originalId !== sess.id
      //  if not originalId !== sess.id === true then
      // return originalHash !== hash(sess);
      // originalId and originalHash are equal false
      // and sess.id it's req.session.id
      // hash
      return originalId !== sess.id || originalHash !== hash(sess);
    }

    // check if session has been saved
    function isSaved(sess) {
      return originalId === sess.id && savedHash === hash(sess);
    }

    // determine if session should be destroyed
    function shouldDestroy(req) {
      return req.sessionID && unsetDestroy && req.session == null;
    }

    // determine if session should be saved to store
    // function makes checks and return true or false
    function shouldSave(req) {
      // cannot set cookie without a session ID
      // if sessionID !== string return false
      if (typeof req.sessionID !== 'string') {
        debug('session ignored because of bogus req.sessionID %o', req.sessionID);
        return false;
      }
      //
      return !saveUninitializedSession && cookieId !== req.sessionID
        // checks if session has been modified
        ? isModified(req.session)
        // isSaved returns this: return originalId === sess.id && savedHash === hash(sess);
        // if session not saved return false
        : !isSaved(req.session)
    } // function shouldSave(req) {

    // determine if session should be touched (touch means refresh maxAge)
    function shouldTouch(req) {
      // cannot set cookie without a session ID
      if (typeof req.sessionID !== 'string') {
        debug('session ignored because of bogus req.sessionID %o', req.sessionID);
        return false;
      }

      return cookieId === req.sessionID && !shouldSave(req);
    }

    // determine if cookie should be set on response
    // return false or true
    function shouldSetCookie(req) {
      // cannot set cookie without a session ID
      // if sessionID not equal string, return false
      if (typeof req.sessionID !== 'string') {
        return false;
      }
      // if cookieId != req.sessionID will be retured saveUninitializedSession value if it is equal true
      // instead isModified(req.session)
      // : will be returned rollingSessions if true, else
      // req.session.cookie.expires != null && isModified(req.session)
      // console.log(req.session);
      // console.log(hash(req.session));
      return cookieId != req.sessionID
        ? saveUninitializedSession || isModified(req.session)
        : rollingSessions || req.session.cookie.expires != null && isModified(req.session);
    } // function shouldSetCookie(req) {

    // generate a session if the browser doesn't send a sessionID
    if (!req.sessionID) {
      debug('no SID sent, generating session');
      generate();
      next(); // start a new middleware
      return;
    }


    // if browser sends session fetch it from database Initialize of session from start
    // generate the session object
    debug('fetching %s', req.sessionID);
    // get is function from connect-redis, accept session id and calback function
    store.get(req.sessionID, function(err, sess){
      // error handling
      if (err) {
        debug('error %j', err);

        if (err.code !== 'ENOENT') {
          next(err);
          return;
        }

        generate();
      // no session
      } else if (!sess) {
        debug('no session found');
        generate();
      // populate req.session
      } else {
        debug('session found');
        store.createSession(req, sess);
        originalId = req.sessionID;
        originalHash = hash(sess);

        // if don't need to resave saveHash = originalHash
        // our session will not change hash
        if (!resaveSession) {
          savedHash = originalHash
        }

        wrapmethods(req.session);
      }

      next(); // allow running other middleware
    }); // store.get(req.sessionID, function(err, sess){ /* this is get session from store */
  }; // return function session(req, res, next) /* it might a closure */
}; // function session(options) /* main function of all middleware */

/**
 * Generate a session ID for a new session.
 *
 * @return {String}
 * @private
 */

function generateSessionId(sess) {
  // this is npm module uid-safe
  // Create cryptographically secure UIDs safe for both cookie and URL usage.
  return uid(24);
}

/**
 * Get the session ID cookie from request.
 *
 * @return {string}
 * @private
 */

// a helper function that returns unsigned cookies
function getcookie(req, name, secrets) {
  // return all cookies form req
  // console.log(req.headers.cookie);
  var header = req.headers.cookie;
  var raw;
  var val;

  // read from cookie header
  // if cookie exists
  if (header) {
    // cookie.parse it's funciton from npm cookie that parse cookies and return an object
    var cookies = cookie.parse(header);
    // console.log(cookies);
    // name is passed in this function argument
    raw = cookies[name];
    // console.log(raw);
    // if exist cookie raw
    if (raw) {
      if (raw.substr(0, 2) === 's:') { // get first two symbols and compare with 's:'
        // unsigncookie is our custom function accept name secret
        // slice - The slice() method returns a shallow copy of a portion of an array into a new array object selected from begin to end (end not included)
        val = unsigncookie(raw.slice(2), secrets);
        // console.log(val);
        if (val === false) {
          debug('cookie signature invalid');
          val = undefined;
        }
      } else {
        debug('cookie unsigned')
      }
    }
  }

  // now it seems not to need
  // back-compat read from cookieParser() signedCookies data
  // if not exists val and exists req.signedCookies then val = req.signedCookies[name]
  if (!val && req.signedCookies) {
    val = req.signedCookies[name];
    if (val) {
      deprecate('cookie should be available in req.headers.cookie');
    }
  }

  // back-compat read from cookieParser() cookies data
  // if val not exists but exists req.cookies
  // then val = raw = req.cookies[name]
  if (!val && req.cookies) {
    raw = req.cookies[name];

    if (raw) {
      if (raw.substr(0, 2) === 's:') {
        val = unsigncookie(raw.slice(2), secrets);

        if (val) {
          deprecate('cookie should be available in req.headers.cookie');
        }

        if (val === false) {
          debug('cookie signature invalid');
          val = undefined;
        }
      } else {
        debug('cookie unsigned')
      }
    }
  }

  return val;
} // function getcookie(req, name, secrets) {

/**
 * Hash the given `sess` object omitting changes to `.cookie`.
 *
 * @param {Object} sess
 * @return {String}
 * @private
 */
// it's a halper function that accept session object
// sess = req.session
// function returns something like this 197427101 (check sum)
function hash(sess) {
  // crc - Module for calculating Cyclic Redundancy Check (CRC) for Node.js and the Browser.
  // var crc = require('crc').crc32;
  // console.log(sess);
  // here JSON.stringify accepts sess that is req.session and apply to her
  // callback function and removes 'coockie' property
  // then crc
  // return number summing
  return crc(JSON.stringify(sess, function (key, val) {
    // console.log('key = ' + key + ' val = ' +  val);
    // ignore sess.cookie property
    if (this === sess && key === 'cookie') {
      return
    }

    // console.log('val = ' + val);
    return val // this is a reqursively call. it will use val to dig deeper
  }))
} // function hash(sess) {

/**
 * Determine if request is secure.
 *
 * @param {Object} req
 * @param {Boolean} [trustProxy]
 * @return {Boolean}
 * @private
 */

// function return false or true
function issecure(req, trustProxy) {
  // socket is https server
  // if exists connection and encrypted, return true
  if (req.connection && req.connection.encrypted) {
    return true;
  }

  // do not trust proxy
  // if we set up opt.proxy to false
  if (trustProxy === false) {
    return false;
  }

  // no explicit trust; try req.secure from express
  if (trustProxy !== true) {
    var secure = req.secure;
    // typeof return string 'boolen', then secure = secure, else false
    return typeof secure === 'boolean'
      ? secure
      : false;
  }

  // read the proto from x-forwarded-proto header
  var header = req.headers['x-forwarded-proto'] || '';
  // indexOf returns the first index where element could be found
  // it will seek ',' index in header array
  // in this case header is array of symbols
  var index = header.indexOf(',');
  // if something found proto = index and index != -1 (means something was found by header.indexOf(','))
  var proto = index !== -1
    // substr return string from 0 to index in lowercase
    ? header.substr(0, index).toLowerCase().trim()
    // simply translate header to lowercase
    : header.toLowerCase().trim()
  // if proto === https return true
  return proto === 'https';
}

/**
 * Set cookie on response.
 *
 * @private
 */
// a custom halper function
function setcookie(res, name, val, secret, options) {
  // name var name = opts.name || opts.key || 'connect.sid' by default
  // val is req.sessionID
  // secret is secret[0]
  // options = req.session.cookie.data

  // signature = require('cookie-signature')
  var signed = 's:' + signature.sign(val, secret);

  // make serialization
  // cookie.serialize(name, value, options)
  // console.log(options);
  var data = cookie.serialize(name, signed, options);
  // console.log(data);

  debug('set-cookie %s', data);
  // what is the res.getHeader('set-cookie')
  // this is something from onHeaders = require('on-headers') module
  var prev = res.getHeader('set-cookie') || [];
  // console.log(prev);
  // console.log(res.getHeader); //[]
  // concat returns a new array with prev + data elements, prev and data aren't changed
  var header = Array.isArray(prev) ? prev.concat(data) : [prev, data];
  // console.log('header = ', header);

  // and this the same onHeaders = require('on-headers'), normally it is not have this functions
  res.setHeader('set-cookie', header)
}

/**
 * Verify and decode the given `val` with `secrets`.
 *
 * @param {String} val
 * @param {Array} secrets
 * @returns {String|Boolean}
 * @private
 */
 // our custome helper function it returns unsigned value
function unsigncookie(val, secrets) {
  // secrets is Array of secret keys
  for (var i = 0; i < secrets.length; i++) {
    // secrets[i] has whole word
    // signature.usign is npm module cookie-signature
    var result = signature.unsign(val, secrets[i]);

    if (result !== false) {
      return result;
    }
  }

  return false;
}
